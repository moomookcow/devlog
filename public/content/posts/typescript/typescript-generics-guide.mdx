---
title: "TypeScript 제네릭 활용법"
excerpt: "재사용 가능한 타입을 만드는 TypeScript 제네릭의 모든 것"
author: "moomookcow"
publishedAt: "2024-01-14"
readingTime: 3
viewCount: 856
likes: 42
comments: 5
category: "TypeScript"
tags: ["TypeScript", "Generic"]
isPublished: true
---

# TypeScript 제네릭 활용법

TypeScript의 제네릭(Generics)은 재사용 가능한 컴포넌트를 만들 때 유용한 강력한 도구입니다. 이 글에서는 제네릭의 기본 개념부터 고급 활용법까지 실무 예제와 함께 알아보겠습니다.

## 1. 제네릭의 기본 개념

제네릭은 타입을 매개변수로 받아서 다양한 타입에 대해 동작하는 코드를 작성할 수 있게 해줍니다.

```typescript
// 기본 제네릭 함수
function identity<T>(arg: T): T {
  return arg;
}

// 사용 예시
const stringResult = identity<string>("Hello"); // string
const numberResult = identity<number>(42); // number
const booleanResult = identity<boolean>(true); // boolean

// 타입 추론으로 생략 가능
const inferred = identity("Hello"); // T는 string으로 추론
```

## 2. 제네릭 인터페이스와 클래스

### 인터페이스에서 제네릭 사용

```typescript
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

// 사용 예시
interface User {
  id: number;
  name: string;
  email: string;
}

interface Product {
  id: number;
  title: string;
  price: number;
}

const userResponse: ApiResponse<User> = {
  data: { id: 1, name: "John", email: "john@example.com" },
  status: 200,
  message: "Success",
};

const productResponse: ApiResponse<Product> = {
  data: { id: 1, title: "Laptop", price: 999 },
  status: 200,
  message: "Success",
};
```

### 클래스에서 제네릭 사용

```typescript
class Repository<T> {
  private items: T[] = [];

  add(item: T): void {
    this.items.push(item);
  }

  findById(id: number): T | undefined {
    return this.items.find((item: any) => item.id === id);
  }

  getAll(): T[] {
    return [...this.items];
  }

  update(id: number, updatedItem: Partial<T>): boolean {
    const index = this.items.findIndex((item: any) => item.id === id);
    if (index !== -1) {
      this.items[index] = { ...this.items[index], ...updatedItem };
      return true;
    }
    return false;
  }

  delete(id: number): boolean {
    const index = this.items.findIndex((item: any) => item.id === id);
    if (index !== -1) {
      this.items.splice(index, 1);
      return true;
    }
    return false;
  }
}

// 사용 예시
interface User {
  id: number;
  name: string;
  email: string;
}

const userRepository = new Repository<User>();

userRepository.add({ id: 1, name: "John", email: "john@example.com" });
userRepository.add({ id: 2, name: "Jane", email: "jane@example.com" });

const user = userRepository.findById(1);
console.log(user); // { id: 1, name: "John", email: "john@example.com" }
```

## 3. 제네릭 제약 조건 (Generic Constraints)

제네릭에 제약 조건을 추가하여 특정 속성을 가진 타입만 허용할 수 있습니다.

```typescript
// 기본 제약 조건
interface Lengthwise {
  length: number;
}

function logLength<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}

logLength("Hello"); // 5
logLength([1, 2, 3]); // 3
logLength({ length: 10, value: "test" }); // 10
// logLength(123); // Error: Argument of type 'number' is not assignable to parameter of type 'Lengthwise'

// 키 제약 조건
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "John", age: 30, city: "Seoul" };
const name = getProperty(person, "name"); // string
const age = getProperty(person, "age"); // number
// const invalid = getProperty(person, "invalid"); // Error: Argument of type '"invalid"' is not assignable to parameter of type '"name" | "age" | "city"'
```

## 4. 조건부 타입 (Conditional Types)

조건부 타입을 사용하면 타입에 따라 다른 타입을 반환할 수 있습니다.

```typescript
// 기본 조건부 타입
type IsString<T> = T extends string ? true : false;

type Test1 = IsString<string>; // true
type Test2 = IsString<number>; // false

// 유틸리티 타입 만들기
type NonNullable<T> = T extends null | undefined ? never : T;

type Test3 = NonNullable<string | null>; // string
type Test4 = NonNullable<number | undefined>; // number

// 함수 반환 타입 추출
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getUser(): { id: number; name: string } {
  return { id: 1, name: "John" };
}

type UserReturnType = ReturnType<typeof getUser>; // { id: number; name: string }
```

## 5. 매핑된 타입 (Mapped Types)

기존 타입을 기반으로 새로운 타입을 만들 수 있습니다.

```typescript
// 모든 속성을 선택적으로 만들기
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// 모든 속성을 읽기 전용으로 만들기
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// 모든 속성을 필수로 만들기
type Required<T> = {
  [P in keyof T]-?: T[P];
};

// 사용 예시
interface User {
  id: number;
  name: string;
  email: string;
}

type PartialUser = Partial<User>;
// { id?: number; name?: string; email?: string; }

type ReadonlyUser = Readonly<User>;
// { readonly id: number; readonly name: string; readonly email: string; }

// 커스텀 매핑된 타입
type Stringify<T> = {
  [K in keyof T]: string;
};

type StringifiedUser = Stringify<User>;
// { id: string; name: string; email: string; }
```

## 6. 실무 예제: API 클라이언트

실제 프로젝트에서 사용할 수 있는 제네릭 API 클라이언트를 만들어보겠습니다.

```typescript
// API 응답 타입
interface ApiResponse<T> {
  data: T;
  success: boolean;
  message: string;
  timestamp: string;
}

// API 에러 타입
interface ApiError {
  code: string;
  message: string;
  details?: any;
}

// HTTP 메서드 타입
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";

// API 클라이언트 클래스
class ApiClient {
  private baseUrl: string;

  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }

  private async request<T>(
    endpoint: string,
    method: HttpMethod = "GET",
    body?: any
  ): Promise<ApiResponse<T>> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        method,
        headers: {
          "Content-Type": "application/json",
        },
        body: body ? JSON.stringify(body) : undefined,
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      return data;
    } catch (error) {
      throw new Error(
        `API request failed: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    }
  }

  // GET 요청
  async get<T>(endpoint: string): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, "GET");
  }

  // POST 요청
  async post<T>(endpoint: string, body: any): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, "POST", body);
  }

  // PUT 요청
  async put<T>(endpoint: string, body: any): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, "PUT", body);
  }

  // DELETE 요청
  async delete<T>(endpoint: string): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, "DELETE");
  }
}

// 사용 예시
interface User {
  id: number;
  name: string;
  email: string;
  createdAt: string;
}

interface CreateUserRequest {
  name: string;
  email: string;
}

const apiClient = new ApiClient("https://api.example.com");

// 사용자 목록 조회
const usersResponse = await apiClient.get<User[]>("/users");
console.log(usersResponse.data); // User[]

// 사용자 생성
const newUser = await apiClient.post<User>("/users", {
  name: "John Doe",
  email: "john@example.com",
} as CreateUserRequest);
console.log(newUser.data); // User

// 사용자 수정
const updatedUser = await apiClient.put<User>("/users/1", {
  name: "John Updated",
});
console.log(updatedUser.data); // User

// 사용자 삭제
await apiClient.delete<void>("/users/1");
```

## 7. 고급 제네릭 패턴

### 제네릭 유틸리티 함수

```typescript
// 배열에서 특정 속성으로 그룹화
function groupBy<T, K extends keyof T>(
  array: T[],
  key: K
): Record<string, T[]> {
  return array.reduce((groups, item) => {
    const groupKey = String(item[key]);
    if (!groups[groupKey]) {
      groups[groupKey] = [];
    }
    groups[groupKey].push(item);
    return groups;
  }, {} as Record<string, T[]>);
}

// 사용 예시
interface Person {
  name: string;
  age: number;
  city: string;
}

const people: Person[] = [
  { name: "John", age: 25, city: "Seoul" },
  { name: "Jane", age: 30, city: "Busan" },
  { name: "Bob", age: 25, city: "Seoul" },
];

const groupedByAge = groupBy(people, "age");
// { "25": [{ name: 'John', age: 25, city: 'Seoul' }, { name: 'Bob', age: 25, city: 'Seoul' }], "30": [{ name: 'Jane', age: 30, city: 'Busan' }] }

const groupedByCity = groupBy(people, "city");
// { "Seoul": [{ name: 'John', age: 25, city: 'Seoul' }, { name: 'Bob', age: 25, city: 'Seoul' }], "Busan": [{ name: 'Jane', age: 30, city: 'Busan' }] }

// 배열에서 중복 제거
function uniqueBy<T, K extends keyof T>(array: T[], key: K): T[] {
  const seen = new Set();
  return array.filter((item) => {
    const keyValue = item[key];
    if (seen.has(keyValue)) {
      return false;
    }
    seen.add(keyValue);
    return true;
  });
}

const uniquePeople = uniqueBy(people, "city");
// [{ name: 'John', age: 25, city: 'Seoul' }, { name: 'Jane', age: 30, city: 'Busan' }]
```

## 결론

TypeScript의 제네릭은 타입 안전성을 유지하면서 재사용 가능한 코드를 작성할 수 있게 해주는 강력한 도구입니다.

### 주요 포인트

1. **기본 제네릭**: 함수, 인터페이스, 클래스에서 사용
2. **제약 조건**: extends를 사용한 타입 제한
3. **조건부 타입**: 타입에 따른 조건부 로직
4. **매핑된 타입**: 기존 타입을 변환하여 새로운 타입 생성
5. **실무 활용**: API 클라이언트, 유틸리티 함수 등

제네릭을 적절히 활용하면 더 안전하고 유지보수하기 쉬운 TypeScript 코드를 작성할 수 있습니다.

### 참고 자료

- [TypeScript 제네릭 공식 문서](https://www.typescriptlang.org/docs/handbook/generics.html)
- [TypeScript 고급 타입](https://www.typescriptlang.org/docs/handbook/advanced-types.html)
- [TypeScript 유틸리티 타입](https://www.typescriptlang.org/docs/handbook/utility-types.html)
