---
title: "React + TypeScript 베스트 프랙티스 가이드"
excerpt: "React와 TypeScript를 함께 사용할 때 알아야 할 핵심 패턴과 베스트 프랙티스를 정리했습니다."
author: "moomookcow"
publishedAt: "2024-01-15"
readingTime: 8
viewCount: 1247
likes: 89
comments: 12
category: "React"
tags: ["React", "TypeScript", "Frontend", "JavaScript", "Best Practices"]
isPublished: true
---

# React + TypeScript 베스트 프랙티스

React와 TypeScript를 함께 사용하면 더 안전하고 유지보수하기 쉬운 코드를 작성할 수 있습니다. 이 글에서는 실무에서 자주 사용되는 패턴들을 정리해보겠습니다.

## 1. 컴포넌트 Props 타입 정의

```typescript
interface ButtonProps {
  variant: "primary" | "secondary" | "outline";
  size: "sm" | "md" | "lg";
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
}

const Button: React.FC<ButtonProps> = ({
  variant,
  size,
  children,
  onClick,
  disabled = false,
}) => {
  return (
    <button
      className={`btn btn-${variant} btn-${size}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
};
```

## 2. 커스텀 훅 타입 정의

```typescript
interface UseApiResult<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

function useApi<T>(url: string): UseApiResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const refetch = useCallback(async () => {
    try {
      setLoading(true);
      const response = await fetch(url);
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : "An error occurred");
    } finally {
      setLoading(false);
    }
  }, [url]);

  useEffect(() => {
    refetch();
  }, [refetch]);

  return { data, loading, error, refetch };
}
```

## 3. 이벤트 핸들러 타입

```typescript
const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  setValue(e.target.value);
};

const handleFormSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  // 폼 제출 로직
};

const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  e.preventDefault();
  // 클릭 로직
};
```

## 4. 제네릭 컴포넌트

```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  keyExtractor: (item: T) => string | number;
}

function List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {
  return (
    <ul>
      {items.map((item) => (
        <li key={keyExtractor(item)}>{renderItem(item)}</li>
      ))}
    </ul>
  );
}

// 사용 예시
const users = [
  { id: 1, name: "John", email: "john@example.com" },
  { id: 2, name: "Jane", email: "jane@example.com" },
];

<List
  items={users}
  keyExtractor={(user) => user.id}
  renderItem={(user) => (
    <div>
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  )}
/>;
```

## 5. 타입 가드 활용

```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

interface Admin extends User {
  permissions: string[];
}

function isAdmin(user: User | Admin): user is Admin {
  return "permissions" in user;
}

function renderUser(user: User | Admin) {
  if (isAdmin(user)) {
    // 여기서 user는 Admin 타입으로 추론됨
    return (
      <div>
        Admin: {user.name} - {user.permissions.join(", ")}
      </div>
    );
  }

  // 여기서 user는 User 타입으로 추론됨
  return (
    <div>
      User: {user.name} - {user.email}
    </div>
  );
}
```

## 결론

TypeScript와 React를 함께 사용하면 컴파일 타임에 오류를 잡을 수 있어 더 안전한 코드를 작성할 수 있습니다. 위의 패턴들을 활용하여 더 나은 React 애플리케이션을 만들어보세요!

## 참고 자료

- [TypeScript 공식 문서](https://www.typescriptlang.org/)
- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/)
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
